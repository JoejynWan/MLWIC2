# srun --pty --account="iwctml" -t 0-02:00 --mem=128000 /bin/bash
# module load swset/2018.05  gcc/7.3.0 r/3.5.2-py27 r-rgdal/1.2-16-py27 r-sf/0.5-5-py27 r-rcpp/1.0.0-py27

#library(raster)
library(lubridate) 
library(tidyverse) 
#library(amt) 
#library(glmmTMB) 
library(INLA) 
#library(lme4)


# change wd depending on location. All code here will be using relative paths
setwd("~/Desktop/APHIS/resource_selection_model")
#setwd("/project/iwctml/mtabak/APHIS/rsf") # on teton

# make data like inla example
dat1 <- read_tsv("./data/Tejon_wildpigs_Prelimdata_Used_and_Available.txt", col_names=TRUE)
# scale covariates
n_preCovs <- 9
n_postCovs <- 3
datS <- as.data.frame(cbind(dat1[,1:n_preCovs], 
                            scale(dat1[,(n_preCovs +1):(ncol(dat1)-n_postCovs)]),
                            dat1[,(ncol(dat1) - n_postCovs+1):ncol(dat1)]))
dat2 <- datS
dat2$date_fix <- as.POSIXct(dat2$Date_Time, format="%m/%d/%Y %H:%M", tz="GMT")

# switch
dat3 <- dat2 %>%
  select(x_coord=`x`, y_coord=`y`,
    y=`Used_Avail`,
         #t=`date_fix`,
         id=`Indiv_ID`,
         NHDP1600 = `NHDP1600`,
    DecMix200 = `DecMix200`,
         ValSlo1600 = `ValSlo1600`,
         EVI_3200 = `EVI_3200`)



# make this differently without dealing witht the spatial stuff
# rsf <- dat3 %>% 
#   mutate(id = as.numeric(factor(id)))
rsf <- transform(dat3, id=match(id, unique(id)))

# create a separate ID variable with different names for each random effect
# will need to add more if more random effects
rsf$id0 <- rsf$id1 <- rsf$id2 <- rsf$id3 <- rsf$id

# generate a weights variable: weighting 0s by 1000
rsf$weights <- ifelse(rsf$y==1, 1, 1000)

# formula. This is the black box part
formula <- y ~ NHDP1600 + ValSlo1600 + DecMix200 + EVI_3200 +
  # random effects are coded with the f() 
  f(id, model = "iid", # random intercepts
    hyper = list(theta = list(initial = log(1e-6), # variance of intercepts is 10^6. This is specified as the log of the precision
                              fixed = TRUE))) + 
  f(id0, NHDP1600, values = 1:max(rsf$id), # values are all of the individuals (we want a random effect for each ind)
    model = "iid",
    hyper = list(theta = list(initial = log(1), fixed = FALSE, # initial variance of 1 and is not fixed
                              prior = "pc.prec", param = c(1, .05) # this is a PC prior
    ))) +
  f(id1, ValSlo1600, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) + 
  f(id2, DecMix200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) +
  f(id3, EVI_3200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) )


# set options to allow weighted likelihoods
inla.setOption("enable.inla.argument.weights", TRUE)

# inla() call
# on teton: 
INLA:::inla.dynload.workaround()
toc <- Sys.time()
m2 <- inla(formula, weights=rsf$weights, 
           family = "binomial", data = rsf)#,
           #control.compute = list(waic=FALSE))#, num.threads=1)
tic <- Sys.time()
runtime <- tic-toc
runtime

# summary
m2$summary.fixed[,c(1,3,5)]
summary(m2)

# extract coeffieiencs
m2$marginals.fixed # this is where the "posterior" values for each coefficient hide
lapply(m2$marginals.fixed, FUN=function(x) mean(x[,1]))

# same reduced model without weights
inla.setOption("enable.inla.argument.weights", FALSE)
#m_unweighted <- 
toc <- Sys.time()
m2 <- inla(formula, 
           family = "binomial", data = rsf,
           #control.compute = list(waic=TRUE)
            num.threads=1)
tic <- Sys.time()
runtime <- tic-toc
runtime

# summary
m2$summary.fixed[-1,c(1,3,5)]
summary(m2)

# extract coefficients

#----- also run a full model to compare
INLA:::inla.dynload.workaround()
dat4 <- dat2 %>%
  select(x_coord=`x`, y_coord=`y`,
         y=`Used_Avail`,
         #t=`date_fix`,
         id=`Indiv_ID`,
         NHDP1600 = `NHDP1600`,
         DecMix200 = `DecMix200`,
         Evergr3200 = `Evergr3200`,
         Grass3200 = `Grass3200`,
         Shrub3200 = `Shrub3200`,
         Forest3200 = `Forest3200`,
         CanCov3200 = `CanCov3200`,
         ValSlo1600 = `ValSlo1600`,
         EVI_3200 = `EVI_3200`) # still excluding NDVI (same as EVI) and RdgSup (same as ValSlo)

rsf <- transform(dat4, id=match(id, unique(id)))

# create a separate ID variable with different names for each random effect
# will need to add more if more random effects
rsf$id0 <- rsf$id1 <- rsf$id2 <- rsf$id3 <- rsf$id4 <- rsf$id5 <- rsf$id6 <- rsf$id7 <- rsf$id8 <- rsf$id

# generate a weights variable: weighting 0s by 1000
rsf$weights <- ifelse(rsf$y==1, 1, 1000)

# formula. This is the black box part
formula <- y ~ NHDP1600 + ValSlo1600 + DecMix200 + EVI_3200 + Evergr3200 +
  Grass3200 + Shrub3200 + Forest3200 + CanCov3200  +
  # random effects are coded with the f() 
  f(id, model = "iid", # random intercepts
    hyper = list(theta = list(initial = log(1e-6), # variance of intercepts is 10^6. This is specified as the log of the precision
                              fixed = TRUE))) + 
  f(id0, NHDP1600, values = 1:max(rsf$id), # values are all of the individuals (we want a random effect for each ind)
    model = "iid",
    hyper = list(theta = list(initial = log(1), fixed = FALSE, # initial variance of 1 and is not fixed
                              prior = "pc.prec", param = c(1, .05) # this is a PC prior
    ))) +
  f(id1, ValSlo1600, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) + 
  f(id2, DecMix200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) +
  f(id3, EVI_3200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) +
  f(id4, Evergr3200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) +
  f(id5, Grass3200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) +
  f(id6, Shrub3200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) +
  f(id7, Forest3200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) +
  f(id8, CanCov3200, values = 1:max(rsf$id), model="iid", # this effect has the same prior structure as above
    hyper = list(theta = list(initial = log(1), fixed = FALSE,
                              prior = "pc.prec", param = c(1, .05))) ) 

# run model with weights
inla.setOption("enable.inla.argument.weights", TRUE)
toc <- Sys.time()
m2 <- inla(formula, weights=rsf$weights, 
           family = "binomial", data = rsf,
           control.compute = list(waic=TRUE))#, num.threads=1)
tic <- Sys.time()
runtime <- tic-toc
runtime

# summary
m2$summary.fixed[-1,c(1,3,5)]
summary(m2)

# run full model witout weights
inla.setOption("enable.inla.argument.weights", FALSE)
toc <- Sys.time()
m2 <- inla(formula,  
           family = "binomial", data = rsf,
           control.compute = list(waic=TRUE))#, num.threads=1)
tic <- Sys.time()
runtime <- tic-toc
runtime

# summary
m2$summary.fixed[-1,c(1,3,5)]
summary(m2)

#-----------------------------------------------------------------
# archive
#-----------------------------------------------------------------
{ # doing with GIS like they did
  # nest and make tracks
  dat_all <- dat3 %>% nest(-id)
  dat_all <- dat_all %>%
    mutate(trk = map(data, function(d) {
      amt::make_track(d, x, y, t) #%>% #, crs = sp::CRS("+init=epsg:4326")) %>%
      #amt::transform_coords(sp::CRS("+init=epsg:5070")) 
    }))
  str(dat_all$trk[[1]])
  
  dat_all <- dat_all %>%
    mutate(trk = map(data, function(d) {
      amt::make_track(d, x, y, t, crs = sp::CRS("+init=epsg:4326")) %>%
        amt::transform_coords(sp::CRS("+init=epsg:5070")) }))
  
  # bring in GIS data
  gisloc <- "/Users/mikeytabak/Desktop/APHIS/resource_selection_model/spatial_data/GIS_layers/"
  NHDP1600 <- raster(paste0(gisloc, "NHDP1600.tif"))
  DecMix200 <- raster(paste0(gisloc, "Deciduous_Mixed_200m.tif"))
  EVI_3200 <- raster(paste0(gisloc, "EVI_3200.tif"))
  ValSlo1600 <- raster(paste0(gisloc, "ValSlo1600.tif"))
  extent(ValSlo1600)==extent(NHDP1600) # have to exclude others because different extent
  names(ValSlo1600) <- "ValSlo1600"
  names(NHDP1600) <- "NHDP1600"
  crs(ValSlo1600)
  
  
  # make rsf data
  set.seed(1234)
  rsf <- dat_all %>%
    mutate(rp = map(trk, function(x) {
      # covariates
      NHDP1600 <- scale(NHDP1600) #scale(NHDP1600@data@values)
      #DecMix200 <- scale(DecMix200)
      #EVI_3200 <- scale(EVI_3200)
      ValSlo1600 <- scale(ValSlo1600)
      cov <- stack(NHDP1600, ValSlo1600)
      x <- x %>% track_resample(rate = minutes(10), tolerance = seconds(120)) %>%
        filter_min_n_burst()
      x <- x %>% random_points() %>% 
        extract_covariates(cov)
    })) %>% select(id, rp) %>% unnest() %>%
    mutate(
      #y = 1, 
      y = as.numeric(case_),
      id = as.numeric(factor(id))) #%>% 
  #select(id, y, NHDP1600, ValSlo1600 )
}


dat1 <- read_tsv("./data/Tejon_wildpigs_Prelimdata_Used_and_Available.txt", col_names=TRUE)  %>%
  filter(!is.na(`Date_Time`)) %>% #*** this means filtering out all of the 0s. Will this work?
  select(x=`x`, y=`y`,
         t=as.POSIXct(dat1$Date_Time, format="%m/%d/%Y %H:%M", tz="GMT"),
         #date=as.Date(as.character(dat$Date_Time), "%m/%d/%Y"),
         #t=col_datetime(`Date_Time`, format = "%m/%d/%Y %H:%M"),
         id=`Indiv_ID`)

dat1$date_event <- as.Date(as.character(dat1$Date_Time), "%m/%d/%Y")
dat1$posD <- as.POSIXlt(as.Date(as.character(dat1$Date_Time), "%m/%d/%Y%H:%M"))
dat1$time_event <- strftime(dat1$Date_Time, "%m/%d/%Y %H:%M")
as.POSIXct(dat1$Date_Time, format="%m/%d/%Y %H:%M", tz="GMT") # works!
dat1 <- read_csv("./data/Tejon_wildpigs_Prelimdata_Used_and_Available.csv")  %>%
  # opened text file in Word and changed date column to date format
  filter(!is.na(dat1$Date_Time)) %>% #*** this means filtering out all of the 0s. Will this work?
  select(x=`x`, y=`y`,
         t=`Date_Time`,
         #date=as.Date(as.character(dat$Date_Time), "%m/%d/%Y"),
         #t=col_datetime(`Date_Time`, format = "%m/%d/%Y %H:%M"),
         t=as.POSIXct(dat1$Date_Time, format="%m/%d/%Y %H:%M", tz="GMT"),
         id=`Indiv_ID`)
dat1$date_event <- as.Date(as.character(dat1$t), "%m/%d/%Y")

# posterior mode of variances
marginals_mode <- sapply(m2$marginals.hyperpar, function(x)
  inla.mmarginal(inla.tmarginal(function(x) 1/x, x))) 
names(marginals_mode) <- sapply(as.vector(as.character(names(marginals_mode))),
                                function(y) gsub("Precision", x=y, "Mode of variance"))
marginals_mode
